# -*- coding: utf-8 -*-
"""ml.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1ZSqz1td6vTKiPDghzVzkpHuU3cZwnYlD
"""

import pandas as pd
import os
import time
ratings_filename = 'train.csv'


df_ratings = pd.read_csv(ratings_filename,
    usecols=['userId', 'movieId', 'rating'],
    dtype={'userId': 'int32', 'movieId': 'int32', 'rating': 'float32'})

df_movie_features = df_ratings.pivot(
    index='userId',
    columns='movieId',
    values='rating'
).fillna(0)

df_movie_features

ratings_filename_test = 'test.csv'


df_ratings_test = pd.read_csv(ratings_filename_test,
    usecols=['userId', 'movieId', 'rating'],
    dtype={'userId': 'int32', 'movieId': 'int32', 'rating': 'float32'})

df_movie_features_test = df_ratings_test.pivot(
    index='userId',
    columns='movieId',
    values='rating'
).fillna(0)

df_movie_features_test

df_ratings_test[~df_ratings_test.movieId.isin(df_ratings.movieId)]

df_ratings_test[~df_ratings_test.userId.isin(df_ratings.userId)]

import numpy as np
import math

K=50
alpha=0.01
beta = 0.001
R = np.array(df_movie_features)
latent_dim = K
iterations = 20
num_users, num_items = R.shape
P=np.random.normal(scale=1./latent_dim, size=(num_users, latent_dim))
Q=np.random.normal(scale=1./latent_dim, size=(num_items, latent_dim))
b_u = np.zeros(num_users)
b_i = np.zeros(num_items)
b = np.mean(R[np.where(R != 0)])
samples = [
    (i, j, R[i, j])
    for i in range(num_users)
    for j in range(num_items)
    if R[i, j] > 0
]


def train():
    for i in range(iterations):
        np.random.shuffle(samples)
        sgd()
        losss = mse()
        print("Iteration = ", i, ", losses=", losss)

def mse():
    xs, ys = R.nonzero()
    predicted = full_matrix()
    error = 0
    counter=0
    for x, y in zip(xs, ys):
        error += pow(R[x, y] - predicted[x, y], 2)
        counter+=1
    return np.sqrt(error/counter)

def sgd():
    for i, j, r in samples:
        prediction = get_rating(i, j)
        if math.isnan(prediction):
          get_rating_with_print(i,j)
          break
        e = (r - prediction)

        b_u[i] += alpha * (e - beta * b_u[i])
        b_i[j] += alpha * (e - beta * b_i[j])

        P[i, :] += alpha * (e * Q[j, :] - beta * P[i,:])
        Q[j, :] += alpha * (e * P[i, :] - beta * Q[j,:])

def get_rating(i, j):
    return b + b_u[i] + b_i[j] + P[i, :].dot(Q[j, :].T)

def full_matrix():
    return b + b_u[:,np.newaxis] + b_i[np.newaxis:,] + P.dot(Q.T)


begin_time_camputing_mf = time.time()
print(begin_time_camputing_mf)
train()
time_computing_mf = time.time() - begin_time_camputing_mf
print(time_computing_mf)

preds_df = pd.DataFrame(full_matrix())

preds_df.to_pickle("model")

preds_df = pd.read_pickle("model")

def recommend_movies(preds_df, userID, original_ratings_df, num_recommendations=5):
  pred_df = pd.DataFrame(np.array(preds_df), columns=df_movie_features.columns)
  sorted_user_predictions = (pred_df.iloc[userID-1].sort_values(ascending=False))
  user_data = original_ratings_df[original_ratings_df.userId == (userID)]
  return (pd.DataFrame(sorted_user_predictions.drop(user_data.movieId))[0:num_recommendations] / pd.DataFrame(sorted_user_predictions.drop(user_data.movieId)).max() * 4)


begin_recommend_time_mf = time.time()
print("recomendation for user", pd.unique(df_ratings_test.userId)[280])
print(recommend_movies(preds_df, pd.unique(df_ratings_test.userId)[280], df_ratings, 20))
recommend_time_mf = time.time() - begin_recommend_time_mf
print(recommend_time_mf)